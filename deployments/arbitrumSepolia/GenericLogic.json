{
  "address": "0x739c93545CAD9EE3202A524ef50ebfDaf452C8dF",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "loan",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newRate",
          "type": "uint256"
        }
      ],
      "name": "ChangeRate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "decreasingAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "currencyAmount",
          "type": "uint256"
        }
      ],
      "name": "DecreaseCapitalReserve",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "decreasingAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "currencyAmount",
          "type": "uint256"
        }
      ],
      "name": "DecreaseIncomeReserve",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "increasingAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCapitalReserve",
          "type": "uint256"
        }
      ],
      "name": "IncreaseCapitalReserve",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "loan",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rate",
          "type": "uint256"
        }
      ],
      "name": "SetRate",
      "type": "event"
    }
  ],
  "transactionHash": "0x0f8dd974406c1dbed3ac83050de621ef6e0ff8c13c588f41ade218864c65f540",
  "receipt": {
    "to": null,
    "from": "0xC52a72eDdcA008580b4Efc89eA9f343AfF11FeA3",
    "contractAddress": "0x739c93545CAD9EE3202A524ef50ebfDaf452C8dF",
    "transactionIndex": 1,
    "gasUsed": "17516263",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa9c9860ef4359b2784222c646c613f37da748610c7061fe42c60111438684de7",
    "transactionHash": "0x0f8dd974406c1dbed3ac83050de621ef6e0ff8c13c588f41ade218864c65f540",
    "logs": [],
    "blockNumber": 60337172,
    "cumulativeGasUsed": "17516263",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "d74ce3ac52532bb456b599bdc8ee57ee",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loan\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"ChangeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decreasingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"}],\"name\":\"DecreaseCapitalReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decreasingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"}],\"name\":\"DecreaseIncomeReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increasingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCapitalReserve\",\"type\":\"uint256\"}],\"name\":\"IncreaseCapitalReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loan\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"SetRate\",\"type\":\"event\"}],\"devdoc\":{\"author\":\"Untangled Team\",\"kind\":\"dev\",\"methods\":{},\"title\":\"Untangled's SecuritizaionPoolNAV contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Main entry point for senior LPs (a.k.a. capital providers)  Automatically invests across borrower pools using an adjustable strategy.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/logic/GenericLogic.sol\":\"GenericLogic\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\",\"keccak256\":\"0xe73087c5001a37cf7186b3709377c7ceb01a0d38fb908723d1464cea66b4958c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x0e1f0f5f62f67a881cd1a9597acbc0a5e4071f3c2c10449a183b922ae7272e3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"contracts/libraries/Configuration.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity 0.8.19;\\r\\n\\r\\n/// @title Configuration\\r\\n/// @author Untangled Team\\r\\nlibrary Configuration {\\r\\n    // NEVER EVER CHANGE THE ORDER OF THESE!\\r\\n    // You can rename or append. But NEVER change the order.\\r\\n    enum CONTRACT_TYPE {\\r\\n        SECURITIZATION_MANAGER,\\r\\n        SECURITIZATION_POOL,\\r\\n        NOTE_TOKEN_FACTORY,\\r\\n        SENIOR_TOKEN_MANAGER,\\r\\n        JUNIOR_TOKEN_MANAGER,\\r\\n        EPOCH_EXECUTOR,\\r\\n        DISTRIBUTION_ASSESSOR,\\r\\n        LOAN_ASSET_TOKEN,\\r\\n        LOAN_KERNEL,\\r\\n        SECURITIZATION_POOL_VALUE_SERVICE,\\r\\n        GO\\r\\n    }\\r\\n\\r\\n    enum NOTE_TOKEN_TYPE {\\r\\n        SENIOR,\\r\\n        JUNIOR\\r\\n    }\\r\\n\\r\\n    enum ASSET_PURPOSE {\\r\\n        LOAN,\\r\\n        INVOICE\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x19d48a27b3b35d91fb4a5e19a2cfbd7ad5aea8bacc153fd615912892730799d2\",\"license\":\"AGPL-3.0-only\"},\"contracts/libraries/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity 0.8.19;\\r\\n\\r\\n// import '../storage/Registry.sol';\\r\\nimport './Configuration.sol';\\r\\nimport './UnpackLoanParamtersLib.sol';\\r\\n\\r\\nuint256 constant RATE_SCALING_FACTOR = 10 ** 4;\\r\\n\\r\\nuint256 constant ONE_HUNDRED_PERCENT = 100 * RATE_SCALING_FACTOR;\\r\\n\\r\\nuint256 constant ONE = 10 ** 27;\\r\\nuint256 constant WRITEOFF_RATE_GROUP_START = 1000 * ONE;\\r\\n\\r\\nbytes32 constant OWNER_ROLE = keccak256('OWNER_ROLE');\\r\\nbytes32 constant ORIGINATOR_ROLE = keccak256('ORIGINATOR_ROLE');\\r\\nbytes32 constant BACKEND_ADMIN_ROLE = keccak256('BACKEND_ADMIN');\\r\\nbytes32 constant SIGNER_ROLE = keccak256('SIGNER_ROLE');\\r\\nbytes32 constant SUPER_ADMIN_ROLE = keccak256('SUPER_ADMIN');\\r\\nbytes32 constant POOL_ADMIN_ROLE = keccak256('POOL_CREATOR');\\r\\n\\r\\n// In PoolNAV we use this\\r\\nbytes32 constant POOL = keccak256('POOL');\\r\\n\\r\\nuint256 constant PRICE_DECIMAL = 10 ** 18;\\r\\n\\r\\nbytes32 constant VALIDATOR_ROLE = keccak256('VALIDATOR_ROLE');\\r\\n\\r\\nbytes32 constant MINTER_ROLE = keccak256('MINTER_ROLE');\\r\\n\\r\\n// In Go\\r\\nbytes32 constant ZAPPER_ROLE = keccak256('ZAPPER_ROLE');\\r\\n\\r\\n// in ERC1155PresetPauserUpgradeable\\r\\nbytes32 constant PAUSER_ROLE = keccak256('PAUSER_ROLE');\\r\\n\\r\\nlibrary DataTypes {\\r\\n    struct NoteToken {\\r\\n        address poolAddress;\\r\\n        address noteTokenAddress;\\r\\n        uint256 balance;\\r\\n        uint256 apy;\\r\\n    }\\r\\n    struct RiskScore {\\r\\n        uint32 daysPastDue;\\r\\n        uint32 advanceRate;\\r\\n        uint32 penaltyRate;\\r\\n        uint32 interestRate;\\r\\n        uint32 probabilityOfDefault;\\r\\n        uint32 lossGivenDefault;\\r\\n        uint32 writeOffAfterGracePeriod;\\r\\n        uint32 gracePeriod;\\r\\n        uint32 collectionPeriod;\\r\\n        uint32 writeOffAfterCollectionPeriod;\\r\\n        uint32 discountRate;\\r\\n    }\\r\\n\\r\\n    struct LoanEntry {\\r\\n        address debtor;\\r\\n        address principalTokenAddress;\\r\\n        bytes32 termsParam; // actually inside this param was already included P token address\\r\\n        uint256 salt;\\r\\n        uint256 issuanceBlockTimestamp;\\r\\n        uint256 expirationTimestamp;\\r\\n        uint8 riskScore;\\r\\n        Configuration.ASSET_PURPOSE assetPurpose;\\r\\n    }\\r\\n    struct NFTAsset {\\r\\n        address tokenAddress;\\r\\n        uint256 tokenId;\\r\\n    }\\r\\n\\r\\n    struct NewPoolParams {\\r\\n        uint256 debtCeiling;\\r\\n        address currency;\\r\\n        uint32 minFirstLossCushion;\\r\\n        bool validatorRequired;\\r\\n    }\\r\\n\\r\\n    /// @notice details of the underlying collateral\\r\\n    struct NFTDetails {\\r\\n        uint128 futureValue;\\r\\n        uint128 maturityDate;\\r\\n        uint128 risk;\\r\\n        address debtor;\\r\\n        address principalTokenAddress;\\r\\n        uint256 salt;\\r\\n        uint256 issuanceBlockTimestamp;\\r\\n        uint256 expirationTimestamp;\\r\\n        Configuration.ASSET_PURPOSE assetPurpose;\\r\\n        bytes32 termsParam;\\r\\n        uint256 principalAmount;\\r\\n        uint256 termStartUnixTimestamp;\\r\\n        uint256 termEndUnixTimestamp;\\r\\n        UnpackLoanParamtersLib.AmortizationUnitType amortizationUnitType;\\r\\n        uint256 termLengthInAmortizationUnits;\\r\\n        uint256 interestRate;\\r\\n    }\\r\\n\\r\\n    /// @notice stores all needed information of an interest rate group\\r\\n    struct Rate {\\r\\n        // total debt of all loans with this rate\\r\\n        uint256 pie;\\r\\n        // accumlated rate index over time\\r\\n        uint256 chi;\\r\\n        // interest rate per second\\r\\n        uint256 ratePerSecond;\\r\\n        // penalty rate per second\\r\\n        uint256 penaltyRatePerSecond;\\r\\n        // accumlated penalty rate index over time\\r\\n        uint256 penaltyChi;\\r\\n        // last time the rate was accumulated\\r\\n        uint48 lastUpdated;\\r\\n        // time start to penalty\\r\\n        uint48 timeStartPenalty;\\r\\n    }\\r\\n\\r\\n    /// @notice details of the loan\\r\\n    struct LoanDetails {\\r\\n        uint128 borrowed;\\r\\n        // only auth calls can move loan into different writeOff group\\r\\n        bool authWriteOff;\\r\\n    }\\r\\n\\r\\n    /// @notice details of the write off group\\r\\n    struct WriteOffGroup {\\r\\n        // denominated in (10^27)\\r\\n        uint128 percentage;\\r\\n        // amount of days after the maturity days that the writeoff group can be applied by default\\r\\n        uint128 overdueDays;\\r\\n        uint128 riskIndex;\\r\\n    }\\r\\n\\r\\n    struct Storage {\\r\\n        bool validatorRequired;\\r\\n        uint64 firstAssetTimestamp;\\r\\n        RiskScore[] riskScores;\\r\\n        NFTAsset[] nftAssets;\\r\\n        address[] tokenAssetAddresses;\\r\\n        mapping(address => bool) existsTokenAssetAddress;\\r\\n        address sotToken;\\r\\n        address jotToken;\\r\\n        address underlyingCurrency;\\r\\n        uint256 incomeReserve;\\r\\n        uint256 capitalReserve;\\r\\n        address beneficiary;\\r\\n        uint256 protocolFee;\\r\\n        uint256 earlyExitFee;\\r\\n        uint256 exitTimestamp;\\r\\n        uint32 minFirstLossCushion;\\r\\n        uint64 openingBlockTimestamp;\\r\\n        // by default it is address(this)\\r\\n        address pot;\\r\\n        // for base (sell-loan) operation\\r\\n        uint256 paidPrincipalAmountSOT;\\r\\n        uint256 interestRateSOT; // Annually, support 4 decimals num\\r\\n        uint256 totalAssetRepaidCurrency;\\r\\n        uint256 debtCeiling;\\r\\n        /// @notice Interest Rate Groups are identified by a `uint` and stored in a mapping\\r\\n        mapping(uint256 => Rate) rates;\\r\\n        mapping(uint256 => uint256) pie;\\r\\n        /// @notice mapping from loan => rate\\r\\n        mapping(uint256 => uint256) loanRates;\\r\\n        /// @notice mapping from loan => grace time\\r\\n\\r\\n        uint256 loanCount;\\r\\n        // loan => loan principal\\r\\n        mapping(uint256 => uint256) balances;\\r\\n        // sum of loan principal\\r\\n        uint256 balance;\\r\\n        // nft => details\\r\\n        mapping(bytes32 => NFTDetails) details;\\r\\n        // loan => details\\r\\n        mapping(uint256 => LoanDetails) loanDetails;\\r\\n        // timestamp => bucket\\r\\n        mapping(uint256 => uint256) buckets;\\r\\n        WriteOffGroup[] writeOffGroups;\\r\\n        // Write-off groups will be added as rate groups to the pile with their index\\r\\n        // in the writeOffGroups array + this number\\r\\n        //        uint256 constant WRITEOFF_RATE_GROUP_START = 1000 * ONE;\\r\\n        //        uint256 constant INTEREST_RATE_SCALING_FACTOR_PERCENT = 10 ** 4;\\r\\n\\r\\n        // Discount rate applied on every asset's fv depending on its maturityDate.\\r\\n        // The discount decreases with the maturityDate approaching.\\r\\n        // denominated in (10^27)\\r\\n        uint256 discountRate;\\r\\n        // latestNAV is calculated in case of borrows & repayments between epoch executions.\\r\\n        // It decreases/increases the NAV by the repaid/borrowed amount without running the NAV calculation routine.\\r\\n        // This is required for more accurate Senior & JuniorAssetValue estimations between epochs\\r\\n        uint256 latestNAV;\\r\\n        uint256 latestDiscount;\\r\\n        uint256 lastNAVUpdate;\\r\\n        // overdue loans are loans which passed the maturity date but are not written-off\\r\\n        uint256 overdueLoans;\\r\\n        // tokenId => latestDiscount\\r\\n        mapping(bytes32 => uint256) latestDiscountOfNavAssets;\\r\\n        mapping(bytes32 => uint256) overdueLoansOfNavAssets;\\r\\n        mapping(uint256 => bytes32) loanToNFT;\\r\\n        // value to view\\r\\n        uint256 totalPrincipalRepaid;\\r\\n        uint256 totalInterestRepaid;\\r\\n        // value to calculate rebase\\r\\n        uint256 seniorDebt;\\r\\n        uint256 seniorBalance;\\r\\n        uint64 lastUpdateSeniorInterest;\\r\\n    }\\r\\n\\r\\n    struct LoanAssetInfo {\\r\\n        uint256[] tokenIds;\\r\\n        uint256[] nonces;\\r\\n        address validator;\\r\\n        bytes validateSignature;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xdf38431a3efe4b9f943c42927052044840498329e7eb06aa0a8bbbe0cbae9068\",\"license\":\"AGPL-3.0-only\"},\"contracts/libraries/Discounting.sol\":{\"content\":\"/// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n// https://github.com/centrifuge/tinlake\\r\\n// src/borrower/feed/discounting.sol -- Tinlake Discounting\\r\\n\\r\\n// Copyright (C) 2022 Centrifuge\\r\\n// Copyright (C) 2023 Untangled.Finance\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport './Math.sol';\\r\\n\\r\\n/// @notice Discounting contract without a state which defines the relevant formulas for the navfeed\\r\\nlibrary Discounting{\\r\\n    /// @notice calculates the discount for a given loan\\r\\n    /// @param discountRate the discount rate\\r\\n    /// @param fv the future value of the loan\\r\\n    /// @param normalizedBlockTimestamp the normalized block time (each day to midnight)\\r\\n    /// @param maturityDate the maturity date of the loan\\r\\n    /// @return result discount for the loan\\r\\n    function calcDiscount(\\r\\n        uint256 discountRate,\\r\\n        uint256 fv,\\r\\n        uint256 normalizedBlockTimestamp,\\r\\n        uint256 maturityDate\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        return Math.rdiv(fv, rpow(discountRate, Math.safeSub(maturityDate, normalizedBlockTimestamp), Math.ONE));\\r\\n    }\\r\\n\\r\\n    /// @notice calculate the future value based on the amount, maturityDate interestRate and recoveryRate\\r\\n    /// @param loanInterestRate the interest rate of the loan\\r\\n    /// @param amount of the loan (principal)\\r\\n    /// @param maturityDate the maturity date of the loan\\r\\n    /// @param recoveryRatePD the recovery rate together with the probability of default of the loan\\r\\n    /// @return fv future value of the loan\\r\\n    function calcFutureValue(\\r\\n        uint256 loanInterestRate,\\r\\n        uint256 amount,\\r\\n        uint256 maturityDate,\\r\\n        uint256 recoveryRatePD\\r\\n    ) internal view returns (uint256 fv) {\\r\\n        uint256 nnow = uniqueDayTimestamp(block.timestamp);\\r\\n        uint256 timeRemaining = 0;\\r\\n        if (maturityDate > nnow) {\\r\\n            timeRemaining = Math.safeSub(maturityDate, nnow);\\r\\n        }\\r\\n\\r\\n        return Math.rmul(Math.rmul(rpow(loanInterestRate, timeRemaining, Math.ONE), amount), recoveryRatePD);\\r\\n    }\\r\\n\\r\\n    /// @notice substracts to values if the result smaller than 0 it returns 0\\r\\n    /// @param x the first value (minuend)\\r\\n    /// @param y the second value (subtrahend)\\r\\n    /// @return result result of the subtraction\\r\\n    function secureSub(uint256 x, uint256 y) internal pure returns (uint256 result) {\\r\\n        if (y > x) {\\r\\n            return 0;\\r\\n        }\\r\\n        return Math.safeSub(x, y);\\r\\n    }\\r\\n\\r\\n    /// @notice normalizes a timestamp to round down to the nearest midnight (UTC)\\r\\n    /// @param timestamp the timestamp which should be normalized\\r\\n    /// @return nTimestamp normalized timestamp\\r\\n    function uniqueDayTimestamp(uint256 timestamp) internal pure returns (uint256 nTimestamp) {\\r\\n        return (1 days) * (timestamp / (1 days));\\r\\n    }\\r\\n\\r\\n    /// @notice rpow peforms a math pow operation with fixed point number\\r\\n    /// adopted from ds-math\\r\\n    /// @param x the base for the pow operation\\r\\n    /// @param n the exponent for the pow operation\\r\\n    /// @param base the base of the fixed point number\\r\\n    /// @return z the result of the pow operation\\r\\n\\r\\n    function rpow(uint256 x, uint256 n, uint256 base) internal pure returns (uint256 z) {\\r\\n        assembly {\\r\\n            switch x\\r\\n            case 0 {\\r\\n                switch n\\r\\n                case 0 {\\r\\n                    z := base\\r\\n                }\\r\\n                default {\\r\\n                    z := 0\\r\\n                }\\r\\n            }\\r\\n            default {\\r\\n                switch mod(n, 2)\\r\\n                case 0 {\\r\\n                    z := base\\r\\n                }\\r\\n                default {\\r\\n                    z := x\\r\\n                }\\r\\n                let half := div(base, 2) // for rounding.\\r\\n                for {\\r\\n                    n := div(n, 2)\\r\\n                } n {\\r\\n                    n := div(n, 2)\\r\\n                } {\\r\\n                    let xx := mul(x, x)\\r\\n                    if iszero(eq(div(xx, x), x)) {\\r\\n                        revert(0, 0)\\r\\n                    }\\r\\n                    let xxRound := add(xx, half)\\r\\n                    if lt(xxRound, xx) {\\r\\n                        revert(0, 0)\\r\\n                    }\\r\\n                    x := div(xxRound, base)\\r\\n                    if mod(n, 2) {\\r\\n                        let zx := mul(z, x)\\r\\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\\r\\n                            revert(0, 0)\\r\\n                        }\\r\\n                        let zxRound := add(zx, half)\\r\\n                        if lt(zxRound, zx) {\\r\\n                            revert(0, 0)\\r\\n                        }\\r\\n                        z := div(zxRound, base)\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd714875aff75d76f628985cd29220e1ec81f30807eb54fd1f1e72461d46e0f7e\",\"license\":\"AGPL-3.0-or-later\"},\"contracts/libraries/Math.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n// tinlake-math/math.sol -- Tinlake Math\\r\\n\\r\\n// Copyright (C) 2022 Centrifuge\\r\\n// Copyright (C) 2023 Untangled.Finance\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nlibrary Math {\\r\\n    uint256 constant ONE = 10 ** 27;\\r\\n\\r\\n    function safeAdd(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x, 'safe-add-failed');\\r\\n    }\\r\\n\\r\\n    function safeSub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x, 'safe-sub-failed');\\r\\n    }\\r\\n\\r\\n    function safeMul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, 'safe-mul-failed');\\r\\n    }\\r\\n\\r\\n    function safeDiv(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = x / y;\\r\\n    }\\r\\n\\r\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = safeMul(x, y) / ONE;\\r\\n    }\\r\\n\\r\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y > 0, 'division by zero');\\r\\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\\r\\n    }\\r\\n\\r\\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y > 0, 'division by zero');\\r\\n        // always rounds up\\r\\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x5da55cb6423fc2810924e3ebea355caae8b5108c280fd3cba416e30083d8526f\",\"license\":\"AGPL-3.0-or-later\"},\"contracts/libraries/TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\n\\r\\nlibrary TransferHelper {\\r\\n    /// @notice Transfers tokens from the targeted address to the given destination\\r\\n    /// @notice Errors with 'STF' if transfer fails\\r\\n    /// @param token The contract address of the token to be transferred\\r\\n    /// @param from The originating address from which the tokens will be transferred\\r\\n    /// @param to The destination address of the transfer\\r\\n    /// @param value The amount to be transferred\\r\\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\\r\\n        (bool success, bytes memory data) = token.call(\\r\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)\\r\\n        );\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers tokens from msg.sender to a recipient\\r\\n    /// @dev Errors with ST if transfer fails\\r\\n    /// @param token The contract address of the token which will be transferred\\r\\n    /// @param to The recipient of the transfer\\r\\n    /// @param value The value of the transfer\\r\\n    function safeTransfer(address token, address to, uint256 value) internal {\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\r\\n    }\\r\\n\\r\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\r\\n    /// @dev Errors with 'SA' if transfer fails\\r\\n    /// @param token The contract address of the token to be approved\\r\\n    /// @param to The target of the approval\\r\\n    /// @param value The amount of the given token the target will be allowed to spend\\r\\n    function safeApprove(address token, address to, uint256 value) internal {\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers ETH to the recipient address\\r\\n    /// @dev Fails with `STE`\\r\\n    /// @param to The destination of the transfer\\r\\n    /// @param value The value to be transferred\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'STE');\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x97c5987f1d2bc096faf1fe6c185ce9efe919b46b47508dd500a0bd16a5d9d0e9\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/UnpackLoanParamtersLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.5.10;\\r\\n\\r\\nlibrary UnpackLoanParamtersLib {\\r\\n    struct InterestParams {\\r\\n        uint256 principalAmount;\\r\\n        uint256 termStartUnixTimestamp;\\r\\n        uint256 termEndUnixTimestamp;\\r\\n        AmortizationUnitType amortizationUnitType;\\r\\n        uint256 termLengthInAmortizationUnits;\\r\\n        // interest rates can, at a maximum, have 4 decimal places of precision.\\r\\n        uint256 interestRate;\\r\\n    }\\r\\n\\r\\n    enum AmortizationUnitType {\\r\\n        MINUTES, // 0 - since 1.0.13\\r\\n        HOURS, // 1\\r\\n        DAYS, // 2\\r\\n        WEEKS, // 3\\r\\n        MONTHS, // 4\\r\\n        YEARS // 5\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *\\r\\n     * Notice: * uint256 (a) reinterprets a as 256-bit unsigned integer. As long as 256 bit = 32 bytes\\r\\n     */\\r\\n    function _bitShiftRight(bytes32 value, uint256 amount) internal pure returns (uint256) {\\r\\n        return uint256(value) / 2 ** amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Unpack parameters from packed bytes32 data\\r\\n     */\\r\\n    function _unpackLoanTermsParametersFromBytes(\\r\\n        bytes32 parameters\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 _principalAmount,\\r\\n            uint256 _interestRate,\\r\\n            uint256 _amortizationUnitType,\\r\\n            uint256 _termLengthInAmortizationUnits,\\r\\n            uint256 _gracePeriodInDays\\r\\n        )\\r\\n    {\\r\\n        // The subsequent 12 bytes of the parameters encode the PRINCIPAL AMOUNT.\\r\\n        bytes32 principalAmountShifted = parameters &\\r\\n            0x00ffffffffffffffffffffffff00000000000000000000000000000000000000;\\r\\n        // The subsequent 3 bytes of the parameters encode the INTEREST RATE.\\r\\n        bytes32 interestRateShifted = parameters & 0x00000000000000000000000000ffffff00000000000000000000000000000000;\\r\\n        // The subsequent 4 bits (half byte) encode the AMORTIZATION UNIT TYPE code.\\r\\n        bytes32 amortizationUnitTypeShifted = parameters &\\r\\n            0x00000000000000000000000000000000f0000000000000000000000000000000;\\r\\n        // The subsequent 12 bytes encode the term length, as denominated in\\r\\n        // the encoded amortization unit.\\r\\n        bytes32 termLengthInAmortizationUnitsShifted = parameters &\\r\\n            0x000000000000000000000000000000000ffffffffffffffffffffffff0000000;\\r\\n\\r\\n        bytes32 gracePeriodInDaysShifted = parameters &\\r\\n            0x000000000000000000000000000000000000000000000000000000000ff00000;\\r\\n\\r\\n        return (\\r\\n            _bitShiftRight(principalAmountShifted, 152),\\r\\n            _bitShiftRight(interestRateShifted, 128),\\r\\n            _bitShiftRight(amortizationUnitTypeShifted, 124),\\r\\n            _bitShiftRight(termLengthInAmortizationUnitsShifted, 28),\\r\\n            _bitShiftRight(gracePeriodInDaysShifted, 20)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Unpack data from hex string which including informations about Loan\\r\\n     */\\r\\n    function unpackParametersFromBytes(\\r\\n        bytes32 parameters\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 _principalAmount,\\r\\n            uint256 _interestRate,\\r\\n            uint256 _amortizationUnitType,\\r\\n            uint256 _termLengthInAmortizationUnits,\\r\\n            uint256 _gracePeriodInDays\\r\\n        )\\r\\n    {\\r\\n        return _unpackLoanTermsParametersFromBytes(parameters);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xfee2d0df159de7c95d678a16abe3887b4beece4db2634ef47082b14f5716c21b\",\"license\":\"AGPL-3.0-only\"},\"contracts/libraries/logic/GenericLogic.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n// https://github.com/centrifuge/tinlake\\r\\n// src/borrower/feed/navfeed.sol -- Tinlake NAV Feed\\r\\n\\r\\n// Copyright (C) 2022 Centrifuge\\r\\n// Copyright (C) 2023 Untangled.Finance\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General internal License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General internal License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General internal License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity 0.8.19;\\r\\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol';\\r\\nimport '../UnpackLoanParamtersLib.sol';\\r\\nimport {DataTypes, ONE_HUNDRED_PERCENT, ONE, WRITEOFF_RATE_GROUP_START} from '../DataTypes.sol';\\r\\nimport {Math} from '../Math.sol';\\r\\nimport {Discounting} from '../Discounting.sol';\\r\\nimport {TransferHelper} from '../TransferHelper.sol';\\r\\n\\r\\n/**\\r\\n * @title Untangled's SecuritizaionPoolNAV contract\\r\\n * @notice Main entry point for senior LPs (a.k.a. capital providers)\\r\\n *  Automatically invests across borrower pools using an adjustable strategy.\\r\\n * @author Untangled Team\\r\\n */\\r\\nlibrary GenericLogic {\\r\\n    event SetRate(bytes32 indexed loan, uint256 rate);\\r\\n    event ChangeRate(bytes32 indexed loan, uint256 newRate);\\r\\n    event IncreaseCapitalReserve(uint256 increasingAmount, uint256 newCapitalReserve);\\r\\n    event DecreaseCapitalReserve(uint256 decreasingAmount, uint256 currencyAmount);\\r\\n    event DecreaseIncomeReserve(uint256 decreasingAmount, uint256 currencyAmount);\\r\\n\\r\\n    /** GETTER */\\r\\n    /// @notice getter function for the maturityDate\\r\\n    /// @param nft_ the id of the nft based on the hash of registry and tokenId\\r\\n    /// @return maturityDate_ the maturityDate of the nft\\r\\n    function maturityDate(\\r\\n        DataTypes.Storage storage _poolStorage,\\r\\n        bytes32 nft_\\r\\n    ) internal view returns (uint256 maturityDate_) {\\r\\n        return uint256(_poolStorage.details[nft_].maturityDate);\\r\\n    }\\r\\n\\r\\n    /// @notice getter function for the risk group\\r\\n    /// @param nft_ the id of the nft based on the hash of registry and tokenId\\r\\n    /// @return risk_ the risk group of the nft\\r\\n\\r\\n    function risk(DataTypes.Storage storage _poolStorage, bytes32 nft_) internal view returns (uint256 risk_) {\\r\\n        return uint256(_poolStorage.details[nft_].risk);\\r\\n    }\\r\\n\\r\\n    /// @notice getter function for the nft value\\r\\n    /// @param nft_ the id of the nft based on the hash of registry and tokenId\\r\\n    /// @return nftValue_ the value of the nft\\r\\n\\r\\n    /// @notice getter function for the future value\\r\\n    /// @param nft_ the id of the nft based on the hash of registry and tokenId\\r\\n    /// @return fv_ future value of the loan\\r\\n    function futureValue(DataTypes.Storage storage _poolStorage, bytes32 nft_) internal view returns (uint256 fv_) {\\r\\n        return uint256(_poolStorage.details[nft_].futureValue);\\r\\n    }\\r\\n\\r\\n    // function discountRate() internal view  returns (uint256) {\\r\\n    //     return uint256(_getStorage().discountRate);\\r\\n    // }\\r\\n\\r\\n    /// @notice getter function for the recovery rate PD\\r\\n    /// @param riskID id of a risk group\\r\\n    /// @return recoveryRatePD_ recovery rate PD of the risk group\\r\\n    function recoveryRatePD(\\r\\n        DataTypes.RiskScore[] storage riskScores,\\r\\n        uint256 riskID,\\r\\n        uint256 termLength\\r\\n    ) internal view returns (uint256 recoveryRatePD_) {\\r\\n        DataTypes.RiskScore memory riskParam = getRiskScoreByIdx(riskScores, riskID);\\r\\n        return\\r\\n            Math.ONE -\\r\\n            (Math.ONE * riskParam.probabilityOfDefault * riskParam.lossGivenDefault * termLength) /\\r\\n            (ONE_HUNDRED_PERCENT * ONE_HUNDRED_PERCENT * 365 days);\\r\\n    }\\r\\n\\r\\n    /// @notice getter function for the borrowed amount\\r\\n    /// @param loan id of a loan\\r\\n    /// @return borrowed_ borrowed amount of the loan\\r\\n    function borrowed(DataTypes.Storage storage _poolStorage, uint256 loan) internal view returns (uint256 borrowed_) {\\r\\n        return uint256(_poolStorage.loanDetails[loan].borrowed);\\r\\n    }\\r\\n\\r\\n    /** UTILITY FUNCTION */\\r\\n    // TODO have to use modifier in main contract\\r\\n    function getRiskScoreByIdx(\\r\\n        DataTypes.RiskScore[] storage riskScores,\\r\\n        uint256 idx\\r\\n    ) internal view returns (DataTypes.RiskScore memory) {\\r\\n        if (idx == 0 || riskScores.length == 0) {\\r\\n            // Default risk score\\r\\n            return\\r\\n                DataTypes.RiskScore({\\r\\n                    daysPastDue: 0,\\r\\n                    advanceRate: 1000000,\\r\\n                    penaltyRate: 0,\\r\\n                    interestRate: 0,\\r\\n                    probabilityOfDefault: 0,\\r\\n                    lossGivenDefault: 0,\\r\\n                    writeOffAfterGracePeriod: 0,\\r\\n                    gracePeriod: 0,\\r\\n                    collectionPeriod: 0,\\r\\n                    writeOffAfterCollectionPeriod: 0,\\r\\n                    discountRate: 0\\r\\n                });\\r\\n        }\\r\\n        // Because risk score upload = risk score index onchain + 1\\r\\n        idx = idx - 1;\\r\\n        return riskScores[idx];\\r\\n    }\\r\\n\\r\\n    /// @notice converts a uint256 to uint128\\r\\n    /// @param value the value to be converted\\r\\n    /// @return converted value to uint128\\r\\n    function toUint128(uint256 value) internal pure returns (uint128 converted) {\\r\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    // TODO have to use modifier in main contract\\r\\n\\r\\n    /// @notice returns if a loan is written off\\r\\n    /// @param loan the id of the loan\\r\\n    function isLoanWrittenOff(DataTypes.Storage storage _poolStorage, uint256 loan) internal view returns (bool) {\\r\\n        return _poolStorage.loanRates[loan] >= WRITEOFF_RATE_GROUP_START;\\r\\n    }\\r\\n\\r\\n    /// @notice calculates and returns the current NAV\\r\\n    /// @return nav_ current NAV\\r\\n    function currentNAV(DataTypes.Storage storage _poolStorage) internal view returns (uint256 nav_) {\\r\\n        (uint256 totalDiscount, uint256 overdue, uint256 writeOffs) = currentPVs(_poolStorage);\\r\\n        return Math.safeAdd(totalDiscount, Math.safeAdd(overdue, writeOffs));\\r\\n    }\\r\\n\\r\\n    function currentNAVAsset(DataTypes.Storage storage _poolStorage, bytes32 tokenId) internal view returns (uint256) {\\r\\n        (uint256 totalDiscount, uint256 overdue, uint256 writeOffs) = currentAV(_poolStorage, tokenId);\\r\\n        return Math.safeAdd(totalDiscount, Math.safeAdd(overdue, writeOffs));\\r\\n    }\\r\\n\\r\\n    /// @notice calculates the present value of the loans together with overdue and written off loans\\r\\n    /// @return totalDiscount the present value of the loans\\r\\n    /// @return overdue the present value of the overdue loans\\r\\n    /// @return writeOffs the present value of the written off loans\\r\\n    function currentPVs(\\r\\n        DataTypes.Storage storage _poolStorage\\r\\n    ) internal view returns (uint256 totalDiscount, uint256 overdue, uint256 writeOffs) {\\r\\n        uint256 latestDiscount;\\r\\n        uint256 overdueLoans;\\r\\n        uint256 discountRate;\\r\\n        uint256 lastNAVUpdate;\\r\\n        {\\r\\n            latestDiscount = _poolStorage.latestDiscount;\\r\\n            overdueLoans = _poolStorage.overdueLoans;\\r\\n            discountRate = _poolStorage.discountRate;\\r\\n            lastNAVUpdate = _poolStorage.lastNAVUpdate;\\r\\n        }\\r\\n        if (latestDiscount == 0) {\\r\\n            // all loans are overdue or writtenOff\\r\\n            return (0, overdueLoans, currentWriteOffs(_poolStorage));\\r\\n        }\\r\\n\\r\\n        uint256 errPV = 0;\\r\\n        uint256 nnow = Discounting.uniqueDayTimestamp(block.timestamp);\\r\\n\\r\\n        // find all new overdue loans since the last update\\r\\n        // calculate the discount of the overdue loans which is needed\\r\\n        // for the total discount calculation\\r\\n        for (uint256 i = lastNAVUpdate; i < nnow; i = i + 1 days) {\\r\\n            uint256 b = _poolStorage.buckets[i];\\r\\n            if (b != 0) {\\r\\n                errPV = Math.safeAdd(\\r\\n                    errPV,\\r\\n                    Math.rmul(b, Discounting.rpow(discountRate, Math.safeSub(nnow, i), Math.ONE))\\r\\n                );\\r\\n                overdue = Math.safeAdd(overdue, b);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return (\\r\\n            // calculate current totalDiscount based on the previous totalDiscount (optimized calculation)\\r\\n            // the overdue loans are incorrectly in this new result with their current PV and need to be removed\\r\\n            Discounting.secureSub(\\r\\n                Math.rmul(latestDiscount, Discounting.rpow(discountRate, Math.safeSub(nnow, lastNAVUpdate), Math.ONE)),\\r\\n                errPV\\r\\n            ),\\r\\n            // current overdue loans not written off\\r\\n            Math.safeAdd(overdueLoans, overdue),\\r\\n            // current write-offs loans\\r\\n            currentWriteOffs(_poolStorage)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function currentAV(\\r\\n        DataTypes.Storage storage _poolStorage,\\r\\n        bytes32 tokenId\\r\\n    ) internal view returns (uint256 totalDiscount, uint256 overdue, uint256 writeOffs) {\\r\\n        uint256 _currentWriteOffs = 0;\\r\\n        uint256 discountRate;\\r\\n        uint256 latestDiscountOfNavAssetsID;\\r\\n        uint256 lastNAVUpdate;\\r\\n        uint256 overdueLoansOfNavAssetsID;\\r\\n        {\\r\\n            discountRate = _poolStorage.discountRate;\\r\\n            latestDiscountOfNavAssetsID = _poolStorage.latestDiscountOfNavAssets[tokenId];\\r\\n            lastNAVUpdate = _poolStorage.lastNAVUpdate;\\r\\n            overdueLoansOfNavAssetsID = _poolStorage.overdueLoansOfNavAssets[tokenId];\\r\\n        }\\r\\n\\r\\n        if (isLoanWrittenOff(_poolStorage, uint256(tokenId))) {\\r\\n            uint256 writeOffGroupIndex = currentValidWriteOffGroup(_poolStorage, uint256(tokenId));\\r\\n            _currentWriteOffs = Math.rmul(\\r\\n                debt(_poolStorage, uint256(tokenId)),\\r\\n                uint256(_poolStorage.writeOffGroups[writeOffGroupIndex].percentage)\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (latestDiscountOfNavAssetsID == 0) {\\r\\n            // all loans are overdue or writtenOff\\r\\n            return (0, overdueLoansOfNavAssetsID, _currentWriteOffs);\\r\\n        }\\r\\n\\r\\n        uint256 errPV = 0;\\r\\n        uint256 nnow = Discounting.uniqueDayTimestamp(block.timestamp);\\r\\n\\r\\n        // loan is overdue since lastNAVUpdate\\r\\n        uint256 mat = Discounting.uniqueDayTimestamp(maturityDate(_poolStorage, tokenId));\\r\\n        if (mat >= lastNAVUpdate && mat < nnow) {\\r\\n            uint256 b = futureValue(_poolStorage, tokenId);\\r\\n            errPV = Math.rmul(b, Discounting.rpow(discountRate, Math.safeSub(nnow, mat), Math.ONE));\\r\\n            overdue = b;\\r\\n        }\\r\\n\\r\\n        return (\\r\\n            Discounting.secureSub(\\r\\n                Math.rmul(\\r\\n                    latestDiscountOfNavAssetsID,\\r\\n                    Discounting.rpow(discountRate, Math.safeSub(nnow, lastNAVUpdate), Math.ONE)\\r\\n                ),\\r\\n                errPV\\r\\n            ),\\r\\n            Math.safeAdd(overdueLoansOfNavAssetsID, overdue),\\r\\n            _currentWriteOffs\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice returns the sum of all write off loans\\r\\n    /// @return sum of all write off loans\\r\\n    function currentWriteOffs(DataTypes.Storage storage _poolStorage) internal view returns (uint256 sum) {\\r\\n        for (uint256 i = 0; i < _poolStorage.writeOffGroups.length; i++) {\\r\\n            // multiply writeOffGroupDebt with the writeOff rate\\r\\n\\r\\n            sum = Math.safeAdd(\\r\\n                sum,\\r\\n                Math.rmul(\\r\\n                    rateDebt(_poolStorage, WRITEOFF_RATE_GROUP_START + i),\\r\\n                    uint256(_poolStorage.writeOffGroups[i].percentage)\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n        return sum;\\r\\n    }\\r\\n\\r\\n    /// @notice calculates and returns the current NAV and updates the state\\r\\n    /// @return nav_ current NAV\\r\\n    function calcUpdateNAV(DataTypes.Storage storage _poolStorage) internal returns (uint256 nav_) {\\r\\n        (uint256 totalDiscount, uint256 overdue, uint256 writeOffs) = currentPVs(_poolStorage);\\r\\n\\r\\n        for (uint i = 0; i < _poolStorage.loanCount; ++i) {\\r\\n            bytes32 _nftID = _poolStorage.loanToNFT[i];\\r\\n\\r\\n            (uint256 td, uint256 ol, ) = currentAV(_poolStorage, _nftID);\\r\\n            _poolStorage.overdueLoansOfNavAssets[_nftID] = ol;\\r\\n            _poolStorage.latestDiscountOfNavAssets[_nftID] = td;\\r\\n        }\\r\\n\\r\\n        _poolStorage.overdueLoans = overdue;\\r\\n        _poolStorage.latestDiscount = totalDiscount;\\r\\n\\r\\n        _poolStorage.latestNAV = Math.safeAdd(Math.safeAdd(totalDiscount, overdue), writeOffs);\\r\\n        _poolStorage.lastNAVUpdate = Discounting.uniqueDayTimestamp(block.timestamp);\\r\\n        return _poolStorage.latestNAV;\\r\\n    }\\r\\n\\r\\n    /// @notice re-calculates the nav in a non-optimized way\\r\\n    ///  the method is not updating the NAV to latest block.timestamp\\r\\n    /// @return nav_ current NAV\\r\\n    function reCalcNAV(DataTypes.Storage storage _poolStorage) internal returns (uint256 nav_) {\\r\\n        // reCalcTotalDiscount\\r\\n        /// @notice re-calculates the totalDiscount in a non-optimized way based on lastNAVUpdate\\r\\n        /// @return latestDiscount_ returns the total discount of the active loans\\r\\n        uint256 latestDiscount_ = 0;\\r\\n        for (uint256 loanID = 1; loanID < _poolStorage.loanCount; loanID++) {\\r\\n            bytes32 nftID_ = nftID(loanID);\\r\\n            uint256 maturityDate_ = maturityDate(_poolStorage, nftID_);\\r\\n\\r\\n            if (maturityDate_ < _poolStorage.lastNAVUpdate) {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            uint256 discountIncrease_ = Discounting.calcDiscount(\\r\\n                _poolStorage.discountRate,\\r\\n                futureValue(_poolStorage, nftID_),\\r\\n                _poolStorage.lastNAVUpdate,\\r\\n                maturityDate_\\r\\n            );\\r\\n            latestDiscount_ = Math.safeAdd(latestDiscount_, discountIncrease_);\\r\\n            _poolStorage.latestDiscountOfNavAssets[nftID_] = discountIncrease_;\\r\\n        }\\r\\n\\r\\n        _poolStorage.latestNAV = Math.safeAdd(\\r\\n            latestDiscount_,\\r\\n            Math.safeSub(_poolStorage.latestNAV, _poolStorage.latestDiscount)\\r\\n        );\\r\\n        _poolStorage.latestDiscount = latestDiscount_;\\r\\n\\r\\n        return _poolStorage.latestNAV;\\r\\n    }\\r\\n\\r\\n    /// @notice returns the nftID for the underlying collateral nft\\r\\n    /// @param loan the loan id\\r\\n    /// @return nftID_ the nftID of the loan\\r\\n    function nftID(uint256 loan) internal pure returns (bytes32 nftID_) {\\r\\n        return bytes32(loan);\\r\\n    }\\r\\n\\r\\n    /// @notice returns the current valid write off group of a loan\\r\\n    /// @param loan the loan id\\r\\n    /// @return writeOffGroup_ the current valid write off group of a loan\\r\\n    function currentValidWriteOffGroup(\\r\\n        DataTypes.Storage storage _poolStorage,\\r\\n        uint256 loan\\r\\n    ) internal view returns (uint256 writeOffGroup_) {\\r\\n        bytes32 nftID_ = nftID(loan);\\r\\n        uint256 maturityDate_ = maturityDate(_poolStorage, nftID_);\\r\\n        uint256 nnow = Discounting.uniqueDayTimestamp(block.timestamp);\\r\\n\\r\\n        DataTypes.NFTDetails memory nftDetail = getAsset(_poolStorage, nftID_);\\r\\n\\r\\n        uint128 _loanRiskIndex = nftDetail.risk - 1;\\r\\n\\r\\n        uint128 lastValidWriteOff = type(uint128).max;\\r\\n        uint128 highestOverdueDays = 0;\\r\\n        // it is not guaranteed that writeOff groups are sorted by overdue days\\r\\n        for (uint128 i = 0; i < _poolStorage.writeOffGroups.length; i++) {\\r\\n            uint128 overdueDays = _poolStorage.writeOffGroups[i].overdueDays;\\r\\n            if (\\r\\n                _poolStorage.writeOffGroups[i].riskIndex == _loanRiskIndex &&\\r\\n                overdueDays >= highestOverdueDays &&\\r\\n                nnow >= maturityDate_ + overdueDays * 1 days\\r\\n            ) {\\r\\n                lastValidWriteOff = i;\\r\\n                highestOverdueDays = overdueDays;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // returns type(uint128).max if no write-off group is valid for this loan\\r\\n        return lastValidWriteOff;\\r\\n    }\\r\\n\\r\\n    function debt(DataTypes.Storage storage _poolStorage, uint256 loan) internal view returns (uint256 loanDebt) {\\r\\n        uint256 rate_ = _poolStorage.loanRates[loan];\\r\\n        uint256 chi_ = _poolStorage.rates[rate_].chi;\\r\\n        uint256 penaltyChi_ = _poolStorage.rates[rate_].penaltyChi;\\r\\n        if (block.timestamp >= _poolStorage.rates[rate_].lastUpdated) {\\r\\n            chi_ = chargeInterest(\\r\\n                _poolStorage.rates[rate_].chi,\\r\\n                _poolStorage.rates[rate_].ratePerSecond,\\r\\n                _poolStorage.rates[rate_].lastUpdated\\r\\n            );\\r\\n            penaltyChi_ = chargeInterest(\\r\\n                _poolStorage.rates[rate_].penaltyChi,\\r\\n                _poolStorage.rates[rate_].penaltyRatePerSecond,\\r\\n                _poolStorage.rates[rate_].lastUpdated\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (penaltyChi_ == 0) {\\r\\n            return toAmount(chi_, _poolStorage.pie[loan]);\\r\\n        } else {\\r\\n            return toAmount(penaltyChi_, toAmount(chi_, _poolStorage.pie[loan]));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function debtWithChi(\\r\\n        DataTypes.Storage storage _poolStorage,\\r\\n        uint256 loan,\\r\\n        uint256 chi,\\r\\n        uint256 penaltyChi\\r\\n    ) internal view returns (uint256 loanDebt) {\\r\\n        if (penaltyChi == 0) {\\r\\n            return toAmount(chi, _poolStorage.pie[loan]);\\r\\n        } else {\\r\\n            return toAmount(penaltyChi, toAmount(chi, _poolStorage.pie[loan]));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function chiAndPenaltyChi(\\r\\n        DataTypes.Storage storage _poolStorage,\\r\\n        uint256 loan\\r\\n    ) internal view returns (uint256 chi, uint256 penaltyChi) {\\r\\n        uint256 rate_ = _poolStorage.loanRates[loan];\\r\\n        chi = _poolStorage.rates[rate_].chi;\\r\\n        penaltyChi = _poolStorage.rates[rate_].penaltyChi;\\r\\n    }\\r\\n\\r\\n    function rateDebt(DataTypes.Storage storage _poolStorage, uint256 rate) internal view returns (uint256 totalDebt) {\\r\\n        uint256 chi_ = _poolStorage.rates[rate].chi;\\r\\n        uint256 penaltyChi_ = _poolStorage.rates[rate].penaltyChi;\\r\\n        uint256 pie_ = _poolStorage.rates[rate].pie;\\r\\n\\r\\n        if (block.timestamp >= _poolStorage.rates[rate].lastUpdated) {\\r\\n            chi_ = chargeInterest(\\r\\n                _poolStorage.rates[rate].chi,\\r\\n                _poolStorage.rates[rate].ratePerSecond,\\r\\n                _poolStorage.rates[rate].lastUpdated\\r\\n            );\\r\\n            penaltyChi_ = chargeInterest(\\r\\n                _poolStorage.rates[rate].penaltyChi,\\r\\n                _poolStorage.rates[rate].penaltyRatePerSecond,\\r\\n                _poolStorage.rates[rate].lastUpdated\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (penaltyChi_ == 0) {\\r\\n            return toAmount(chi_, pie_);\\r\\n        } else {\\r\\n            return toAmount(penaltyChi_, toAmount(chi_, pie_));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setRate(DataTypes.Storage storage _poolStorage, uint256 loan, uint256 rate) internal {\\r\\n        require(_poolStorage.pie[loan] == 0, 'non-zero-debt');\\r\\n        // rate category has to be initiated\\r\\n        require(_poolStorage.rates[rate].chi != 0, 'rate-group-not-set');\\r\\n        _poolStorage.loanRates[loan] = rate;\\r\\n        emit SetRate(nftID(loan), rate);\\r\\n    }\\r\\n\\r\\n    function changeRate(DataTypes.Storage storage _poolStorage, uint256 loan, uint256 newRate) internal {\\r\\n        require(_poolStorage.rates[newRate].chi != 0, 'rate-group-not-set');\\r\\n        if (newRate >= WRITEOFF_RATE_GROUP_START) {\\r\\n            _poolStorage.rates[newRate].timeStartPenalty = uint48(block.timestamp);\\r\\n        }\\r\\n        uint256 currentRate = _poolStorage.loanRates[loan];\\r\\n        drip(_poolStorage, currentRate);\\r\\n        drip(_poolStorage, newRate);\\r\\n        uint256 pie_ = _poolStorage.pie[loan];\\r\\n        uint256 debt_ = toAmount(_poolStorage.rates[currentRate].chi, pie_);\\r\\n        _poolStorage.rates[currentRate].pie = Math.safeSub(_poolStorage.rates[currentRate].pie, pie_);\\r\\n        _poolStorage.pie[loan] = toPie(_poolStorage.rates[newRate].chi, debt_);\\r\\n        _poolStorage.rates[newRate].pie = Math.safeAdd(_poolStorage.rates[newRate].pie, _poolStorage.pie[loan]);\\r\\n        _poolStorage.loanRates[loan] = newRate;\\r\\n        emit ChangeRate(nftID(loan), newRate);\\r\\n    }\\r\\n\\r\\n    function accrue(DataTypes.Storage storage _poolStorage, uint256 loan) internal {\\r\\n        drip(_poolStorage, _poolStorage.loanRates[loan]);\\r\\n    }\\r\\n\\r\\n    function drip(DataTypes.Storage storage _poolStorage, uint256 rate) internal {\\r\\n        if (block.timestamp >= _poolStorage.rates[rate].lastUpdated) {\\r\\n            (uint256 chi, ) = compounding(\\r\\n                _poolStorage.rates[rate].chi,\\r\\n                _poolStorage.rates[rate].ratePerSecond,\\r\\n                _poolStorage.rates[rate].lastUpdated,\\r\\n                _poolStorage.rates[rate].pie\\r\\n            );\\r\\n            _poolStorage.rates[rate].chi = chi;\\r\\n            if (\\r\\n                _poolStorage.rates[rate].penaltyRatePerSecond != 0 &&\\r\\n                _poolStorage.rates[rate].timeStartPenalty != 0 &&\\r\\n                block.timestamp >= _poolStorage.rates[rate].timeStartPenalty\\r\\n            ) {\\r\\n                uint lastUpdated_ = _poolStorage.rates[rate].lastUpdated > _poolStorage.rates[rate].timeStartPenalty\\r\\n                    ? _poolStorage.rates[rate].lastUpdated\\r\\n                    : _poolStorage.rates[rate].timeStartPenalty;\\r\\n                (uint256 penaltyChi, ) = compounding(\\r\\n                    _poolStorage.rates[rate].penaltyChi,\\r\\n                    _poolStorage.rates[rate].penaltyRatePerSecond,\\r\\n                    lastUpdated_,\\r\\n                    _poolStorage.rates[rate].pie\\r\\n                );\\r\\n                _poolStorage.rates[rate].penaltyChi = penaltyChi;\\r\\n            }\\r\\n            _poolStorage.rates[rate].lastUpdated = uint48(block.timestamp);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// Interest functions\\r\\n    // @notice This function provides compounding in seconds\\r\\n    // @param chi Accumulated interest rate over time\\r\\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10\\u02c627)\\r\\n    // @param lastUpdated When the interest rate was last updated\\r\\n    // @param _pie Total sum of all amounts accumulating under one interest rate, divided by that rate\\r\\n    // @return The new accumulated rate, as well as the difference between the debt calculated with the old and new accumulated rates.\\r\\n    function compounding(uint chi, uint ratePerSecond, uint lastUpdated, uint _pie) internal view returns (uint, uint) {\\r\\n        require(block.timestamp >= lastUpdated, 'tinlake-math/invalid-timestamp');\\r\\n        require(chi != 0);\\r\\n        // instead of a interestBearingAmount we use a accumulated interest rate index (chi)\\r\\n        uint updatedChi = _chargeInterest(chi, ratePerSecond, lastUpdated, block.timestamp);\\r\\n        return (updatedChi, Math.safeSub(Math.rmul(updatedChi, _pie), Math.rmul(chi, _pie)));\\r\\n    }\\r\\n\\r\\n    // @notice This function charge interest on a interestBearingAmount\\r\\n    // @param interestBearingAmount is the interest bearing amount\\r\\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10\\u02c627)\\r\\n    // @param lastUpdated last time the interest has been charged\\r\\n    // @return interestBearingAmount + interest\\r\\n    function chargeInterest(\\r\\n        uint interestBearingAmount,\\r\\n        uint ratePerSecond,\\r\\n        uint lastUpdated\\r\\n    ) internal view returns (uint) {\\r\\n        if (block.timestamp >= lastUpdated) {\\r\\n            interestBearingAmount = _chargeInterest(interestBearingAmount, ratePerSecond, lastUpdated, block.timestamp);\\r\\n        }\\r\\n        return interestBearingAmount;\\r\\n    }\\r\\n\\r\\n    function _chargeInterest(\\r\\n        uint interestBearingAmount,\\r\\n        uint ratePerSecond,\\r\\n        uint lastUpdated,\\r\\n        uint current\\r\\n    ) internal pure returns (uint) {\\r\\n        return Math.rmul(Discounting.rpow(ratePerSecond, current - lastUpdated, Math.ONE), interestBearingAmount);\\r\\n    }\\r\\n\\r\\n    // convert pie to debt/savings amount\\r\\n    function toAmount(uint chi, uint _pie) internal pure returns (uint) {\\r\\n        return Math.rmul(_pie, chi);\\r\\n    }\\r\\n\\r\\n    // convert debt/savings amount to pie\\r\\n    function toPie(uint chi, uint amount) internal pure returns (uint) {\\r\\n        return Math.rdivup(amount, chi);\\r\\n    }\\r\\n\\r\\n    function getAsset(\\r\\n        DataTypes.Storage storage _poolStorage,\\r\\n        bytes32 agreementId\\r\\n    ) internal view returns (DataTypes.NFTDetails memory) {\\r\\n        return _poolStorage.details[agreementId];\\r\\n    }\\r\\n\\r\\n    function reserve(DataTypes.Storage storage _poolStorage) internal view returns (uint256) {\\r\\n        return Math.safeAdd(_poolStorage.capitalReserve, _poolStorage.incomeReserve);\\r\\n    }\\r\\n\\r\\n    function increaseCapitalReserve(DataTypes.Storage storage _poolStorage, uint256 amount) internal {\\r\\n        _poolStorage.capitalReserve = Math.safeAdd(_poolStorage.capitalReserve, amount);\\r\\n        emit IncreaseCapitalReserve(amount, _poolStorage.capitalReserve);\\r\\n    }\\r\\n\\r\\n    /// @param amortizationUnitType AmortizationUnitType enum\\r\\n    /// @return the corresponding length of the unit in seconds\\r\\n    function _getAmortizationUnitLengthInSeconds(\\r\\n        UnpackLoanParamtersLib.AmortizationUnitType amortizationUnitType\\r\\n    ) private pure returns (uint256) {\\r\\n        if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.MINUTES) {\\r\\n            return 1 minutes;\\r\\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.HOURS) {\\r\\n            return 1 hours;\\r\\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.DAYS) {\\r\\n            return 1 days;\\r\\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.WEEKS) {\\r\\n            return 7 days;\\r\\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.MONTHS) {\\r\\n            return 30 days;\\r\\n        } else if (amortizationUnitType == UnpackLoanParamtersLib.AmortizationUnitType.YEARS) {\\r\\n            return 365 days;\\r\\n        } else {\\r\\n            revert('Unknown amortization unit type.');\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *   Get parameters by Agreement ID (commitment hash)\\r\\n     */\\r\\n    function unpackParamsForAgreementID(\\r\\n        DataTypes.LoanEntry calldata loan\\r\\n    ) internal view returns (UnpackLoanParamtersLib.InterestParams memory params) {\\r\\n        // The principal amount denominated in the aforementioned token.\\r\\n        uint256 principalAmount;\\r\\n        // The interest rate accrued per amortization unit.\\r\\n        uint256 interestRate;\\r\\n        // The amortization unit in which the repayments installments schedule is defined.\\r\\n        uint256 rawAmortizationUnitType;\\r\\n        // The debt's entire term's length, denominated in the aforementioned amortization units\\r\\n        uint256 termLengthInAmortizationUnits;\\r\\n        uint256 gracePeriodInDays;\\r\\n\\r\\n        (\\r\\n            principalAmount,\\r\\n            interestRate,\\r\\n            rawAmortizationUnitType,\\r\\n            termLengthInAmortizationUnits,\\r\\n            gracePeriodInDays\\r\\n        ) = UnpackLoanParamtersLib.unpackParametersFromBytes(loan.termsParam);\\r\\n\\r\\n        UnpackLoanParamtersLib.AmortizationUnitType amortizationUnitType = UnpackLoanParamtersLib.AmortizationUnitType(\\r\\n            rawAmortizationUnitType\\r\\n        );\\r\\n\\r\\n        // Grant the real origination date\\r\\n        termLengthInAmortizationUnits =\\r\\n            (loan.expirationTimestamp - block.timestamp) /\\r\\n            _getAmortizationUnitLengthInSeconds(amortizationUnitType);\\r\\n\\r\\n        // Calculate term length base on Amortization Unit and number\\r\\n        uint256 termLengthInSeconds = termLengthInAmortizationUnits *\\r\\n            _getAmortizationUnitLengthInSeconds(amortizationUnitType);\\r\\n\\r\\n        return\\r\\n            UnpackLoanParamtersLib.InterestParams({\\r\\n                principalAmount: principalAmount,\\r\\n                interestRate: interestRate,\\r\\n                termStartUnixTimestamp: loan.issuanceBlockTimestamp,\\r\\n                termEndUnixTimestamp: termLengthInSeconds + loan.issuanceBlockTimestamp,\\r\\n                amortizationUnitType: amortizationUnitType,\\r\\n                termLengthInAmortizationUnits: termLengthInAmortizationUnits\\r\\n            });\\r\\n    }\\r\\n    function decreaseCapitalReserve(DataTypes.Storage storage _poolStorage, uint256 currencyAmount) external {\\r\\n        require(_poolStorage.capitalReserve >= currencyAmount, 'insufficient balance of capital reserve');\\r\\n        _poolStorage.capitalReserve = _poolStorage.capitalReserve - currencyAmount;\\r\\n        emit DecreaseCapitalReserve(currencyAmount, _poolStorage.capitalReserve);\\r\\n    }\\r\\n\\r\\n    function decreaseIncomeReserve(DataTypes.Storage storage _poolStorage, uint256 currencyAmount) external {\\r\\n        require(_poolStorage.incomeReserve >= currencyAmount, 'insufficient balance of income reserve');\\r\\n        _poolStorage.incomeReserve = _poolStorage.incomeReserve - currencyAmount;\\r\\n        emit DecreaseIncomeReserve(currencyAmount, _poolStorage.incomeReserve);\\r\\n    }\\r\\n\\r\\n    function setPot(DataTypes.Storage storage _poolStorage, address _pot) external {\\r\\n        require(_poolStorage.pot != _pot, 'SecuritizationPool: Same address with current pot');\\r\\n        _poolStorage.pot = _pot;\\r\\n\\r\\n        if (_pot == address(this)) {\\r\\n            require(\\r\\n                IERC20Upgradeable(_poolStorage.underlyingCurrency).approve(_pot, type(uint256).max),\\r\\n                'SecuritizationPool: Pot not approved'\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function disburse(DataTypes.Storage storage _poolStorage, address usr, uint256 currencyAmount) external {\\r\\n        TransferHelper.safeTransferFrom(_poolStorage.underlyingCurrency, _poolStorage.pot, usr, currencyAmount);\\r\\n    }\\r\\n\\r\\n    function withdraw(DataTypes.Storage storage _poolStorage, address to, uint256 amount) public {\\r\\n        require(_poolStorage.capitalReserve >= amount, 'SecuritizationPool: insufficient balance of capital reserve');\\r\\n        _poolStorage.capitalReserve = _poolStorage.capitalReserve - amount;\\r\\n\\r\\n        TransferHelper.safeTransferFrom(_poolStorage.underlyingCurrency, _poolStorage.pot, to, amount);\\r\\n        emit DecreaseCapitalReserve(amount, _poolStorage.capitalReserve);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x1027ea4569f38f0062682456e1d170eca5b9453a752100a832c4667c29ad5e18\",\"license\":\"AGPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x61078a61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c8063106f946214610066578063b9a6bac614610088578063ba8c666e146100a8578063e329012c146100c8578063eac8a842146100e8575b600080fd5b81801561007257600080fd5b50610086610081366004610652565b610108565b005b81801561009457600080fd5b506100866100a3366004610687565b610136565b8180156100b457600080fd5b506100866100c3366004610652565b6102c5565b8180156100d457600080fd5b506100866100e33660046106b3565b6103c1565b8180156100f457600080fd5b506100866101033660046106b3565b61047b565b6007830154600e840154610131916001600160a01b0390811691600160601b900416848461052c565b505050565b600e8201546001600160a01b03808316600160601b90920416036101bb5760405162461bcd60e51b815260206004820152603160248201527f53656375726974697a6174696f6e506f6f6c3a2053616d652061646472657373604482015270081dda5d1a0818dd5c9c995b9d081c1bdd607a1b60648201526084015b60405180910390fd5b600e820180546bffffffffffffffffffffffff16600160601b6001600160a01b038416908102919091179091553090036102c157600782015460405163095ea7b360e01b81526001600160a01b03838116600483015260001960248301529091169063095ea7b3906044016020604051808303816000875af1158015610245573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061026991906106d5565b6102c15760405162461bcd60e51b8152602060048201526024808201527f53656375726974697a6174696f6e506f6f6c3a20506f74206e6f7420617070726044820152631bdd995960e21b60648201526084016101b2565b5050565b808360090154101561033f5760405162461bcd60e51b815260206004820152603b60248201527f53656375726974697a6174696f6e506f6f6c3a20696e73756666696369656e7460448201527f2062616c616e6365206f66206361706974616c2072657365727665000000000060648201526084016101b2565b80836009015461034f91906106fe565b60098401556007830154600e84015461037d916001600160a01b0390811691600160601b900416848461052c565b60098301546040805183815260208101929092527f2dafce763f70c5a3be13839a2b83b70afe4e62d152c6ecc511791702ccdb6f5f910160405180910390a1505050565b80826009015410156104255760405162461bcd60e51b815260206004820152602760248201527f696e73756666696369656e742062616c616e6365206f66206361706974616c206044820152667265736572766560c81b60648201526084016101b2565b80826009015461043591906106fe565b600983018190556040805183815260208101929092527f2dafce763f70c5a3be13839a2b83b70afe4e62d152c6ecc511791702ccdb6f5f91015b60405180910390a15050565b80826008015410156104de5760405162461bcd60e51b815260206004820152602660248201527f696e73756666696369656e742062616c616e6365206f6620696e636f6d65207260448201526565736572766560d01b60648201526084016101b2565b8082600801546104ee91906106fe565b600883018190556040805183815260208101929092527f22ab51db12c50daf1f97c3c9430c9ef8588fa08afe4a2043d6325bd1b43cb98e910161046f565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b17905291516000928392908816916105909190610725565b6000604051808303816000865af19150503d80600081146105cd576040519150601f19603f3d011682016040523d82523d6000602084013e6105d2565b606091505b50915091508180156105fc5750805115806105fc5750808060200190518101906105fc91906106d5565b61062e5760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b60448201526064016101b2565b505050505050565b80356001600160a01b038116811461064d57600080fd5b919050565b60008060006060848603121561066757600080fd5b8335925061067760208501610636565b9150604084013590509250925092565b6000806040838503121561069a57600080fd5b823591506106aa60208401610636565b90509250929050565b600080604083850312156106c657600080fd5b50508035926020909101359150565b6000602082840312156106e757600080fd5b815180151581146106f757600080fd5b9392505050565b8181038181111561071f57634e487b7160e01b600052601160045260246000fd5b92915050565b6000825160005b81811015610746576020818601810151858301520161072c565b50600092019182525091905056fea26469706673582212207bb5460e23d72d71738277271d73a6350f1a809adbc9e2754bfa9c29d88a248364736f6c63430008130033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c8063106f946214610066578063b9a6bac614610088578063ba8c666e146100a8578063e329012c146100c8578063eac8a842146100e8575b600080fd5b81801561007257600080fd5b50610086610081366004610652565b610108565b005b81801561009457600080fd5b506100866100a3366004610687565b610136565b8180156100b457600080fd5b506100866100c3366004610652565b6102c5565b8180156100d457600080fd5b506100866100e33660046106b3565b6103c1565b8180156100f457600080fd5b506100866101033660046106b3565b61047b565b6007830154600e840154610131916001600160a01b0390811691600160601b900416848461052c565b505050565b600e8201546001600160a01b03808316600160601b90920416036101bb5760405162461bcd60e51b815260206004820152603160248201527f53656375726974697a6174696f6e506f6f6c3a2053616d652061646472657373604482015270081dda5d1a0818dd5c9c995b9d081c1bdd607a1b60648201526084015b60405180910390fd5b600e820180546bffffffffffffffffffffffff16600160601b6001600160a01b038416908102919091179091553090036102c157600782015460405163095ea7b360e01b81526001600160a01b03838116600483015260001960248301529091169063095ea7b3906044016020604051808303816000875af1158015610245573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061026991906106d5565b6102c15760405162461bcd60e51b8152602060048201526024808201527f53656375726974697a6174696f6e506f6f6c3a20506f74206e6f7420617070726044820152631bdd995960e21b60648201526084016101b2565b5050565b808360090154101561033f5760405162461bcd60e51b815260206004820152603b60248201527f53656375726974697a6174696f6e506f6f6c3a20696e73756666696369656e7460448201527f2062616c616e6365206f66206361706974616c2072657365727665000000000060648201526084016101b2565b80836009015461034f91906106fe565b60098401556007830154600e84015461037d916001600160a01b0390811691600160601b900416848461052c565b60098301546040805183815260208101929092527f2dafce763f70c5a3be13839a2b83b70afe4e62d152c6ecc511791702ccdb6f5f910160405180910390a1505050565b80826009015410156104255760405162461bcd60e51b815260206004820152602760248201527f696e73756666696369656e742062616c616e6365206f66206361706974616c206044820152667265736572766560c81b60648201526084016101b2565b80826009015461043591906106fe565b600983018190556040805183815260208101929092527f2dafce763f70c5a3be13839a2b83b70afe4e62d152c6ecc511791702ccdb6f5f91015b60405180910390a15050565b80826008015410156104de5760405162461bcd60e51b815260206004820152602660248201527f696e73756666696369656e742062616c616e6365206f6620696e636f6d65207260448201526565736572766560d01b60648201526084016101b2565b8082600801546104ee91906106fe565b600883018190556040805183815260208101929092527f22ab51db12c50daf1f97c3c9430c9ef8588fa08afe4a2043d6325bd1b43cb98e910161046f565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b17905291516000928392908816916105909190610725565b6000604051808303816000865af19150503d80600081146105cd576040519150601f19603f3d011682016040523d82523d6000602084013e6105d2565b606091505b50915091508180156105fc5750805115806105fc5750808060200190518101906105fc91906106d5565b61062e5760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b60448201526064016101b2565b505050505050565b80356001600160a01b038116811461064d57600080fd5b919050565b60008060006060848603121561066757600080fd5b8335925061067760208501610636565b9150604084013590509250925092565b6000806040838503121561069a57600080fd5b823591506106aa60208401610636565b90509250929050565b600080604083850312156106c657600080fd5b50508035926020909101359150565b6000602082840312156106e757600080fd5b815180151581146106f757600080fd5b9392505050565b8181038181111561071f57634e487b7160e01b600052601160045260246000fd5b92915050565b6000825160005b81811015610746576020818601810151858301520161072c565b50600092019182525091905056fea26469706673582212207bb5460e23d72d71738277271d73a6350f1a809adbc9e2754bfa9c29d88a248364736f6c63430008130033",
  "devdoc": {
    "author": "Untangled Team",
    "kind": "dev",
    "methods": {},
    "title": "Untangled's SecuritizaionPoolNAV contract",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Main entry point for senior LPs (a.k.a. capital providers)  Automatically invests across borrower pools using an adjustable strategy.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}